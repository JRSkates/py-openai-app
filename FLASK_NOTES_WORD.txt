FLASK API IMPLEMENTATION - NOTES

PROJECT CONVERSION
• Converted command-line classifier to REST API using Flask
• Original functionality preserved in cli.py
• All classification logic from viewing_mode.py remains unchanged

MAIN CHANGES - app.py

Before:
- Command-line: python3 app.py "YouTube Title"
- Output: Plain text viewing mode

After:
- HTTP API: POST request with JSON body
- Output: JSON response with viewing_mode and input

Key Setup:
- Classifier initialized once at startup (efficient, maintains cache)
- Flask app runs on http://127.0.0.1:5000
- Debug mode enabled for development

API ENDPOINTS

1. POST/GET /classify
   - Input: {"input": "YouTube title or URL"}
   - Output: {"viewing_mode": "Cinema", "input": "..."}
   - Supports both JSON body (POST)
   - Error handling: 400 for missing input, 500 for failures

2. GET /health
   - Output: {"status": "healthy"}
   - For monitoring/load balancers

3. GET /
   - API documentation endpoint
   - Shows all available endpoints and examples

USAGE EXAMPLES

cURL (Command Line):
curl -X POST http://127.0.0.1:5000/classify \
  -H "Content-Type: application/json" \
  -d '{"input": "Thor Will Return | Avengers"}'

Python:
import requests
response = requests.post(
    "http://127.0.0.1:5000/classify",
    json={"input": "Lakers vs Warriors"}
)
result = response.json()
print(result["viewing_mode"])

JavaScript:
fetch('http://127.0.0.1:5000/classify', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({input: 'Music Video Title'})
})
.then(res => res.json())
.then(data => console.log(data.viewing_mode));

C++ (libcurl):
- Set CURLOPT_URL to endpoint
- Set CURLOPT_POST and CURLOPT_POSTFIELDS
- Add "Content-Type: application/json" header
- Use CURLOPT_WRITEFUNCTION to capture response

RUNNING THE SERVER

Development:
python3 app.py
- Runs on port 5000
- Auto-reloads on code changes
- Debug mode enabled

Production:
pip install gunicorn
gunicorn -w 4 -b 0.0.0.0:5000 app:app
- 4 worker processes
- Bind to all interfaces

RESPONSE FORMATS

Success:
{
  "viewing_mode": "Cinema",
  "input": "Thor Will Return | Avengers"
}

Error (Missing Input):
{
  "error": "Missing 'input' field in JSON body",
  "example": {"input": "Thor Will Return | Avengers"}
}

Error (Classification Failed):
{
  "error": "Classification failed",
  "message": "API key invalid"
}

REQUEST FLOW
HTTP Request → Flask Route → Extract Input → ViewingModeClassifier.classify() → 
Enhanced System Prompt + OpenAI API → Weighted Heuristic Fallback (if needed) → 
Validate Mode → JSON Response

CLASSIFICATION LOGIC (PRESERVED)
All improvements from viewing_mode.py maintained:
• Enhanced system prompt with detailed rules
• TV series detection (S##E##)
• Weighted keyword scoring
• Dual-layer validation (API + fallback)
• 100% accuracy on test suite

FILES ADDED/MODIFIED

Modified:
- app.py: Flask web server (replaced CLI script)
- requirements.txt: Added flask dependency

Added:
- cli.py: Preserved original command-line interface
- FLASK_API_NOTES.md: Detailed documentation

ARCHITECTURE BENEFITS
• Stateless: Each request independent
• Cacheable: LRU cache for repeated queries
• Scalable: Multiple workers/containers
• Language Agnostic: Any HTTP client
• Testable: Easy integration tests
• Monitorable: Health endpoint

CONFIGURATION

Environment Variables:
OPENAI_API_KEY=your-api-key-here
FLASK_ENV=development
FLASK_DEBUG=1

Server Settings (in app.py):
app.run(
    host="0.0.0.0",  # All interfaces
    port=5000,
    debug=True
)

TESTING

Manual:
- Start server: python3 app.py
- Test: curl -X POST http://127.0.0.1:5000/classify ...

Automated:
- python3 tests/test_classification_accuracy.py

FUTURE ENHANCEMENTS (OPTIONAL)
• CORS support for browser clients
• Rate limiting to prevent abuse
• Authentication (API keys/JWT)
• Request/response logging
• Performance metrics
• Batch classification endpoint
• Async processing for queued requests

IMPORTANT NOTES
• Flask built-in server is development only
• Use gunicorn/uwsgi for production
• Classifier instance shared across requests (memory efficient)
• Debug mode auto-reloads on code changes
• All classification logic unchanged from original
